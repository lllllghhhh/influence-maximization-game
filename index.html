<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Traffic Diffusion Game</title>
    <style>
        /* --- å…¨å±€è¨­å®š --- */
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        
        body {
            margin: 0; padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f0f2f5;
            /* é–å®šè¢å¹•é«˜åº¦ï¼Œä½¿ç”¨ dvh å…¼å®¹æ‰‹æ©Ÿç€è¦½å™¨ */
            height: 100dvh; 
            width: 100vw;
            display: flex;
            flex-direction: column; /* å‚ç›´æ’åˆ—ï¼šæ¨™é¡Œ -> ç•«å¸ƒ -> æ§åˆ¶åˆ— */
            overflow: hidden; /* ç¦æ­¢æ•´å€‹é é¢æ²å‹• */
        }

        /* --- é ‚éƒ¨æ¨™é¡Œèˆ‡è³‡è¨Š --- */
        .header {
            padding: 8px 12px;
            background: #fff;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0; /* ç¦æ­¢è¢«å£“ç¸® */
            z-index: 10;
        }
        .stats { font-size: 0.9rem; color: #555; font-weight: bold; }
        .stats span { color: #e74c3c; margin-left: 5px; }

        /* --- ç•«å¸ƒå®¹å™¨ (é—œéµä¿®æ­£) --- */
        #canvas-wrapper {
            flex: 1; /* è‡ªå‹•å¡«æ»¿å‰©é¤˜ç©ºé–“ */
            position: relative;
            width: 100%;
            overflow: hidden;
            background-color: #fff;
            touch-action: none; /* ç¦æ­¢ç€è¦½å™¨é è¨­è§¸æ§è¡Œç‚º */
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* --- åº•éƒ¨æ§åˆ¶åˆ— --- */
        .controls {
            padding: 10px;
            background: #fff;
            border-top: 1px solid #ddd;
            display: flex;
            gap: 8px;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap; /* ç©ºé–“ä¸å¤ æ™‚è‡ªå‹•æ›è¡Œ */
            flex-shrink: 0; /* ç¦æ­¢è¢«å£“ç¸® */
            z-index: 20;
            padding-bottom: env(safe-area-inset-bottom); /* é¿é–‹ iPhone åº•éƒ¨æ©«æ¢ */
        }

        /* --- æŒ‰éˆ•æ¨£å¼ --- */
        .btn {
            padding: 10px 16px; /* åŠ å¤§è§¸æ§ç¯„åœ */
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.2s;
            background-color: #ecf0f1;
            color: #2c3e50;
        }
        .btn:active { transform: scale(0.96); }
        .btn-primary { background-color: #3498db; color: white; }
        .btn-danger { background-color: #e74c3c; color: white; }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }

        input[type="number"] {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 6px;
            width: 70px;
            text-align: center;
            font-size: 16px; /* é˜²æ­¢ iOS æ”¾å¤§ */
        }

        /* --- æµ®å‹•è³‡è¨Šé¢æ¿ --- */
        #data-panel {
            position: absolute;
            top: 10px; right: 10px;
            width: 220px;
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid #ccc;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.15);
            display: flex;
            flex-direction: column;
            max-height: 60%; /* é™åˆ¶é«˜åº¦ï¼Œé¿å…æ“‹ä½å¤ªå¤š */
            transition: opacity 0.3s;
            opacity: 0; pointer-events: none; /* é è¨­éš±è— */
            z-index: 50;
        }
        #data-panel.visible { opacity: 1; pointer-events: auto; }
        #data-panel.minimized { height: auto; width: 140px; }
        #data-panel.minimized .panel-content { display: none; }

        #panel-header {
            padding: 8px;
            background: #eee;
            cursor: move;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-radius: 8px 8px 0 0;
            user-select: none;
        }
        .panel-content {
            overflow-y: auto; /* å…§å®¹å¤ªå¤šæ™‚å¯æ²å‹• */
            flex: 1;
        }
        table { width: 100%; border-collapse: collapse; font-size: 12px; }
        th, td { padding: 6px; text-align: center; border-bottom: 1px solid #eee; }
        th { background: #f8f9fa; position: sticky; top: 0; }
        
        .row-seed { background-color: #fadbd8; }
        .row-active { background-color: #fdedec; }
        .row-wa { background-color: #fef9e7; }
        
        #toast {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 100;
        }

        /* --- æ©«å‘æ¨¡å¼å„ªåŒ– (Landscape) --- */
        @media (orientation: landscape) and (max-height: 500px) {
            .header { padding: 4px 12px; font-size: 0.8rem; }
            .btn { padding: 6px 10px; font-size: 12px; }
            #data-panel { max-height: 80%; width: 180px; }
        }
    </style>
</head>
<body>

    <div class="header">
        <div class="stats">
            Seeds: <span id="ui-seeds">0</span>/3
            <span style="margin-left:10px;">Active:</span> <span id="ui-active">0</span>
        </div>
        <button class="btn" onclick="toggleTable()" style="padding:4px 8px;">ğŸ“Š Data</button>
    </div>

    <div id="canvas-wrapper">
        <canvas id="gameCanvas"></canvas>
        <div id="toast">Message</div>
        
        <div id="data-panel">
            <div id="panel-header">
                <span>Node Data</span>
                <button class="btn-min" onclick="toggleMinimize(event)" style="border:none;background:none;font-weight:bold;">_</button>
            </div>
            <div class="panel-content">
                <table id="data-table">
                    <thead><tr><th>ID</th><th>Thr</th><th>In</th></tr></thead>
                    <tbody id="data-body"></tbody>
                </table>
            </div>
        </div>
    </div>

    <div class="controls">
        <input type="number" id="seedInput" value="2026" placeholder="Map ID">
        <button class="btn btn-primary btn-reset" onclick="reloadMap()">New Map</button>
        <button class="btn btn-danger btn-reset" onclick="resetGame()">Reset</button>
        <button id="btn-start" class="btn btn-primary" onclick="startSim()" disabled>Start Diffusion</button>
    </div>

    <script>
        // --- åƒæ•¸ ---
        const NODE_COUNT = 16; 
        const NODE_RADIUS = 28; // ä¿æŒè¼ƒå¤§çš„åŠå¾‘æ–¹ä¾¿è§¸æ§
        const MAX_SEEDS = 3;

        // --- è®Šæ•¸ ---
        let canvas, ctx;
        let width, height;
        let nodes = []; 
        let seeds = new Set();
        let isSimulating = false;
        let mySeed = 2026;

        // æ‹–æ›³æ§åˆ¶
        let dragNode = null;
        let dragStartPos = {x:0, y:0};
        let isDraggingNode = false; 
        let touchStartTime = 0;

        // --- éš¨æ©Ÿæ•¸ ---
        function seededRandom() {
            mySeed = (mySeed * 9301 + 49297) % 233280;
            return mySeed / 233280;
        }

        window.onload = function() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            
            // RWD è¨­å®š - ç›£è½ wrapper å¤§å°è®ŠåŒ–
            const wrapper = document.getElementById('canvas-wrapper');
            const resizeObserver = new ResizeObserver(() => resizeCanvas());
            resizeObserver.observe(wrapper);
            
            // è¨»å†Šäº‹ä»¶
            canvas.addEventListener('mousedown', onPointerDown);
            canvas.addEventListener('touchstart', onPointerDown, {passive: false});
            
            canvas.addEventListener('mousemove', onPointerMove);
            canvas.addEventListener('touchmove', onPointerMove, {passive: false});
            
            window.addEventListener('mouseup', onPointerUp);
            window.addEventListener('touchend', onPointerUp, {passive: false});

            initDraggablePanel();

            // å»¶é²å•Ÿå‹•ç¢ºä¿å°ºå¯¸æ­£ç¢º
            setTimeout(() => {
                resizeCanvas();
                reloadMap();
                requestAnimationFrame(loop);
            }, 200);
        };

        function resizeCanvas() {
            const wrapper = document.getElementById('canvas-wrapper');
            const rect = wrapper.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            
            // è¨­å®šç•«å¸ƒå¯¦éš›åƒç´ 
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            
            // è¨­å®š CSS é¡¯ç¤ºå¤§å°
            canvas.style.width = '100%';
            canvas.style.height = '100%';
            
            // ç¸®æ”¾ç¹ªåœ–ä¸Šä¸‹æ–‡
            ctx.scale(dpr, dpr);
            
            // é‚è¼¯å¯¬é«˜
            width = rect.width;
            height = rect.height;
        }

        function toggleTable() {
            const panel = document.getElementById('data-panel');
            panel.classList.toggle('visible');
            updateTable();
        }

        function toggleMinimize(e) {
            e.stopPropagation();
            const panel = document.getElementById('data-panel');
            const btn = e.target;
            if(panel.classList.contains('minimized')) {
                panel.classList.remove('minimized');
                btn.innerText = '_';
            } else {
                panel.classList.add('minimized');
                btn.innerText = 'â–¡';
            }
        }

        function initDraggablePanel() {
            const panel = document.getElementById('data-panel');
            const header = document.getElementById('panel-header');
            let isPanelDragging = false;
            let startX, startY, initialLeft, initialTop;

            const startDrag = (e) => {
                if(e.target.classList.contains('btn-min')) return;
                isPanelDragging = true;
                let clientX = e.clientX || (e.touches ? e.touches[0].clientX : 0);
                let clientY = e.clientY || (e.touches ? e.touches[0].clientY : 0);
                startX = clientX;
                startY = clientY;
                initialLeft = panel.offsetLeft;
                initialTop = panel.offsetTop;
                
                document.addEventListener('mousemove', onDrag);
                document.addEventListener('mouseup', stopDrag);
                document.addEventListener('touchmove', onDrag, {passive: false});
                document.addEventListener('touchend', stopDrag);
            };

            const onDrag = (e) => {
                if(!isPanelDragging) return;
                if(e.type === 'touchmove') e.preventDefault();
                
                let clientX = e.clientX || (e.touches ? e.touches[0].clientX : 0);
                let clientY = e.clientY || (e.touches ? e.touches[0].clientY : 0);
                let dx = clientX - startX;
                let dy = clientY - startY;
                
                let newLeft = initialLeft + dx;
                let newTop = initialTop + dy;
                // é™åˆ¶åœ¨ç•«é¢å…§
                let maxLeft = width - panel.offsetWidth;
                let maxTop = height - panel.offsetHeight;

                panel.style.left = Math.max(0, Math.min(maxLeft, newLeft)) + 'px';
                panel.style.top = Math.max(0, Math.min(maxTop, newTop)) + 'px';
            };

            const stopDrag = () => {
                isPanelDragging = false;
                document.removeEventListener('mousemove', onDrag);
                document.removeEventListener('mouseup', stopDrag);
                document.removeEventListener('touchmove', onDrag);
                document.removeEventListener('touchend', stopDrag);
            };

            header.addEventListener('mousedown', startDrag);
            header.addEventListener('touchstart', startDrag, {passive: false});
        }

        function reloadMap() {
            let inputVal = document.getElementById('seedInput').value;
            mySeed = parseInt(inputVal) || 2026;
            resetGameData();
            
            nodes = [];
            let attempts = 0;
            // é‚Šè·
            let padding = NODE_RADIUS * 1.5;
            let safeW = width - 2 * padding;
            let safeH = height - 2 * padding;

            while(nodes.length < NODE_COUNT && attempts < 2000) {
                attempts++;
                let x = padding + seededRandom() * safeW;
                let y = padding + seededRandom() * safeH;
                
                let overlap = false;
                for(let n of nodes) {
                    if(Math.hypot(n.x - x, n.y - y) < NODE_RADIUS * 2.5) {
                        overlap = true; break;
                    }
                }
                if(!overlap) {
                    nodes.push({
                        id: nodes.length + 1,
                        x: x, y: y,
                        power: Math.floor(seededRandom() * 9) + 1, 
                        threshold: Math.floor(seededRandom() * 4) + 2, 
                        currentInput: 0,
                        state: 'normal',
                        neighbors: []
                    });
                }
            }

            let connected = [0]; 
            let unconnected = []; 
            for(let i=1; i<NODE_COUNT; i++) unconnected.push(i);
            let rawPairs = [];

            while(unconnected.length > 0) {
                let uIdx = Math.floor(seededRandom() * connected.length);
                let u = connected[uIdx];
                let bestVIdx = -1;
                let minDist = Infinity;
                
                for(let k=0; k<5; k++) {
                     let tryIdx = Math.floor(seededRandom() * unconnected.length);
                     let vCand = unconnected[tryIdx];
                     let d = Math.hypot(nodes[u].x - nodes[vCand].x, nodes[u].y - nodes[vCand].y);
                     if(d < minDist) { minDist = d; bestVIdx = tryIdx; }
                }
                if(bestVIdx === -1) bestVIdx = 0;
                
                let v = unconnected[bestVIdx];
                rawPairs.push({u: u, v: v});
                connected.push(v);
                unconnected.splice(bestVIdx, 1);
            }

            for(let i=0; i<NODE_COUNT; i++) {
                let u = i;
                let v = Math.floor(seededRandom() * NODE_COUNT);
                if(u !== v && !rawPairs.some(p => (p.u===u && p.v===v) || (p.u===v && p.v===u))) {
                     if(Math.hypot(nodes[u].x - nodes[v].x, nodes[u].y - nodes[v].y) < width * 0.45) {
                         rawPairs.push({u: u, v: v});
                     }
                }
            }

            let adj = Array.from({length: NODE_COUNT}, () => []);
            rawPairs.forEach(p => { adj[p.u].push(p.v); adj[p.v].push(p.u); });

            for(let i=0; i<NODE_COUNT; i++) {
                let degree = adj[i].length;
                if(degree === 0) continue;
                let weights = [];
                let sum = 0;
                for(let k=0; k<degree; k++) {
                    let r = Math.floor(seededRandom() * 10) + 1; 
                    weights.push(r);
                    sum += r;
                }
                for(let k=0; k<degree; k++) {
                    let targetId = adj[i][k];
                    let w = weights[k] / sum;
                    nodes[i].neighbors.push({
                        target: nodes[targetId], weight: w, active: false 
                    });
                }
            }
            updateTable();
            showToast(`åœ°åœ– ${inputVal} å·²è¼‰å…¥`);
        }

        function resetGameData() {
            isSimulating = false;
            seeds.clear();
            if(nodes.length > 0) {
                nodes.forEach(n => {
                    n.state = 'normal';
                    n.currentInput = 0;
                    n.neighbors.forEach(e => e.active = false);
                });
            }
            updateUI();
            updateTable();
        }

        function updateTable() {
            const tbody = document.getElementById('data-body');
            if(!tbody) return;
            const panel = document.getElementById('data-panel');
            if(!panel.classList.contains('visible')) return;

            let html = '';
            let sortedNodes = [...nodes].sort((a,b) => a.id - b.id);

            sortedNodes.forEach(n => {
                let rowClass = '';
                let inputDisplay = n.currentInput.toFixed(1);
                
                if(n.state === 'seed') {
                    rowClass = 'row-seed';
                    inputDisplay = '(ç¨®å­)';
                } else if(n.state === 'active') {
                    rowClass = 'row-active';
                } else if(n.currentInput > 0) {
                    rowClass = 'row-wa';
                }

                html += `<tr class="${rowClass}">
                    <td><b>${n.id}</b></td>
                    <td>${n.threshold}</td>
                    <td>${inputDisplay}</td>
                </tr>`;
            });
            tbody.innerHTML = html;
        }

        // --- äº’å‹• (ä¿®æ­£è§¸æ§) ---
        function getPointerPos(e) {
            let rect = canvas.getBoundingClientRect();
            let clientX = e.clientX;
            let clientY = e.clientY;
            
            if(e.touches && e.touches.length > 0) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else if (e.changedTouches && e.changedTouches.length > 0) {
                clientX = e.changedTouches[0].clientX;
                clientY = e.changedTouches[0].clientY;
            }

            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }

        function onPointerDown(e) {
            if(isSimulating) return;
            if(e.target !== canvas) return;
            if(e.type === 'touchstart') e.preventDefault();

            let pos = getPointerPos(e);
            
            for(let n of nodes) {
                let d = Math.hypot(pos.x - n.x, pos.y - n.y);
                if(d < NODE_RADIUS * 2) {
                    dragNode = n;
                    dragStartPos = {x: pos.x, y: pos.y};
                    isDraggingNode = false;
                    touchStartTime = Date.now();
                    return;
                }
            }
        }

        function onPointerMove(e) {
            if(!dragNode) return;
            if(e.type === 'touchmove') e.preventDefault();
            
            let pos = getPointerPos(e);
            
            if(!isDraggingNode) {
                let distMoved = Math.hypot(pos.x - dragStartPos.x, pos.y - dragStartPos.y);
                if(distMoved > 15) { // æé«˜å®¹éŒ¯
                    isDraggingNode = true;
                }
            }
            
            if(isDraggingNode) {
                let pad = NODE_RADIUS;
                dragNode.x = Math.max(pad, Math.min(width - pad, pos.x));
                dragNode.y = Math.max(pad, Math.min(height - pad, pos.y));
            }
        }

        function onPointerUp(e) {
            if(e.type === 'touchend' && e.target === canvas) e.preventDefault();

            if(dragNode) {
                let timeDiff = Date.now() - touchStartTime;
                if (!isDraggingNode || timeDiff < 200) {
                    toggleSeed(dragNode);
                }
                dragNode = null; 
                isDraggingNode = false;
            }
        }

        function loop() {
            ctx.clearRect(0,0, canvas.width, canvas.height);
            ctx.fillStyle = '#fff'; 
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            try {
                nodes.forEach(source => {
                    source.neighbors.forEach(edge => {
                        drawCurve(source, edge.target, edge.active, edge.weight, false);
                    });
                });

                nodes.forEach(n => {
                    ctx.beginPath();
                    ctx.arc(n.x, n.y, NODE_RADIUS, 0, Math.PI*2);
                    ctx.shadowColor = 'rgba(0,0,0,0.15)'; ctx.shadowBlur = 4;
                    
                    if(n.state === 'seed') {
                        ctx.fillStyle = '#e74c3c'; ctx.strokeStyle = '#c0392b';
                    } else if(n.state === 'active') {
                        ctx.fillStyle = '#ff7675'; ctx.strokeStyle = '#d63031';
                    } else if(n.currentInput > 0) {
                        ctx.fillStyle = '#ffeaa7'; ctx.strokeStyle = '#fdcb6e';
                    } else {
                        ctx.fillStyle = '#ecf0f1'; ctx.strokeStyle = '#bdc3c7';
                    }
                    
                    ctx.fill();
                    ctx.shadowBlur = 0; ctx.lineWidth = 2; ctx.stroke();

                    ctx.fillStyle = '#2d3436';
                    ctx.font = 'bold 16px Arial'; 
                    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    ctx.fillText(n.id, n.x, n.y);

                    ctx.fillStyle = '#555';
                    ctx.font = 'bold 11px Arial';
                    ctx.fillText(`${n.power} | ${n.threshold}`, n.x, n.y + NODE_RADIUS + 12);

                    if(n.state !== 'seed' && n.currentInput > 0) {
                        ctx.fillStyle = '#0984e3'; 
                        ctx.font = 'bold 14px Arial';
                        ctx.fillText(`R:${n.currentInput.toFixed(1)}`, n.x, n.y - NODE_RADIUS - 12);
                    }
                });

                nodes.forEach(source => {
                    source.neighbors.forEach(edge => {
                        drawCurve(source, edge.target, edge.active, edge.weight, true);
                    });
                });
            } catch (e) {}

            requestAnimationFrame(loop);
        }

        function drawCurve(source, target, isActive, weight, drawLabelOnly) {
            let dx = target.x - source.x;
            let dy = target.y - source.y;
            let dist = Math.sqrt(dx*dx + dy*dy);
            if(dist < 1) return;

            let midX = (source.x + target.x) / 2;
            let midY = (source.y + target.y) / 2;
            let offset = 30; 
            let normX = -dy / dist;
            let normY = dx / dist;
            let ctrlX = midX + normX * offset;
            let ctrlY = midY + normY * offset;

            if(!drawLabelOnly) {
                ctx.beginPath();
                ctx.moveTo(source.x, source.y);
                ctx.quadraticCurveTo(ctrlX, ctrlY, target.x, target.y);
                if(isActive) {
                    ctx.strokeStyle = '#f1c40f'; ctx.lineWidth = 4;
                } else {
                    ctx.strokeStyle = '#ccc'; ctx.lineWidth = 1.5;
                }
                ctx.stroke();

                let t = 0.85; let invT = 1-t;
                let arrowX = invT*invT*source.x + 2*invT*t*ctrlX + t*t*target.x;
                let arrowY = invT*invT*source.y + 2*invT*t*ctrlY + t*t*target.y;
                let tanX = 2*invT*(ctrlX-source.x) + 2*t*(target.x-ctrlX);
                let tanY = 2*invT*(ctrlY-source.y) + 2*t*(target.y-ctrlY);
                drawArrowHead(ctx, arrowX, arrowY, Math.atan2(tanY, tanX));
            } else {
                let t = 0.4; let invT = 1-t;
                let labelX = invT*invT*source.x + 2*invT*t*ctrlX + t*t*target.x;
                let labelY = invT*invT*source.y + 2*invT*t*ctrlY + t*t*target.y;
                let txt = Math.round(weight * 100) + "%";
                ctx.fillStyle = 'rgba(255,255,255,0.8)';
                let metrics = ctx.measureText(txt);
                let w = metrics.width + 4;
                ctx.fillRect(labelX - w/2, labelY - 8, w, 16);
                ctx.fillStyle = '#666';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText(txt, labelX, labelY);
            }
        }

        function drawArrowHead(ctx, x, y, angle) {
            ctx.save(); ctx.translate(x, y); ctx.rotate(angle);
            ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(-7, -3.5); ctx.lineTo(-7, 3.5);
            ctx.closePath(); ctx.fillStyle = ctx.strokeStyle; ctx.fill(); ctx.restore();
        }

        function toggleSeed(n) {
            if(seeds.has(n)) {
                seeds.delete(n);
                n.state = 'normal';
                n.currentInput = 0;
            } else {
                if(seeds.size >= MAX_SEEDS) { showToast("å·²é” 3 å€‹ä¸Šé™"); return; }
                seeds.add(n);
                n.state = 'seed';
                n.currentInput = n.threshold + 99; 
            }
            updateUI();
            updateTable();
        }

        function updateUI() {
            document.getElementById('ui-seeds').innerText = seeds.size;
            let active = nodes.filter(n => n.state === 'seed' || n.state === 'active').length;
            document.getElementById('ui-active').innerText = active;
            document.getElementById('btn-start').disabled = (seeds.size === 0);
        }

        function showToast(msg) {
            let t = document.getElementById('toast');
            t.innerText = msg; t.style.opacity = 1;
            setTimeout(()=>t.style.opacity=0, 2000);
        }

        async function startSim() {
            isSimulating = true;
            document.querySelectorAll('.btn').forEach(b => b.disabled = true);
            showToast("æ“´æ•£ä¸­...");

            let queue = [...seeds];
            let visitedEdges = new Set();

            while(queue.length > 0) {
                await new Promise(r => setTimeout(r, 800));
                let nextQueue = [];

                for(let source of queue) {
                    for(let edge of source.neighbors) {
                        let edgeKey = `${source.id}-${edge.target.id}`;
                        if(visitedEdges.has(edgeKey)) continue;

                        let target = edge.target;
                        if(target.state === 'seed') {
                            visitedEdges.add(edgeKey); continue;
                        }

                        visitedEdges.add(edgeKey);
                        edge.active = true;
                        target.currentInput += source.power * edge.weight;
                    }
                }
                
                nodes.forEach(n => {
                    if(n.state === 'normal' && n.currentInput > n.threshold) {
                        n.state = 'active';
                        nextQueue.push(n);
                    }
                });
                queue = nextQueue;
                updateUI();
                updateTable(); 
            }
            showToast("æ¨¡æ“¬çµæŸ");
            document.querySelector('.btn-reset').disabled = false;
            document.querySelector('.btn-toggle').disabled = false;
        }

        function resetGame() {
            resetGameData();
            document.querySelectorAll('.btn').forEach(b => b.disabled = false);
            document.getElementById('btn-start').disabled = true;
        }
    </script>
</body>
</html>
