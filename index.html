<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>節點守護者 v7 (教師完美版)</title>
    <style>
        /* --- 1. 全局鎖定設定 (解決手機網址列干擾) --- */
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

        html, body {
            margin: 0; padding: 0;
            width: 100%; height: 100%;
            position: fixed; /* 關鍵：鎖死視窗位置 */
            top: 0; left: 0;
            overflow: hidden; /* 禁止捲動 */
            font-family: "Microsoft JhengHei", "Segoe UI", sans-serif;
            background-color: #f0f2f5;
            display: flex; flex-direction: column;
        }

        /* --- 2. 頂部標題 --- */
        header {
            background-color: #2c3e50; color: white; padding: 8px 12px;
            display: flex; justify-content: space-between; align-items: center;
            height: 50px; flex-shrink: 0; /* 禁止壓縮 */
            z-index: 10;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .title h1 { margin: 0; font-size: 1.1rem; line-height: 1.2; white-space: nowrap; }
        .title small { font-size: 0.75rem; color: #bdc3c7; display: block; }

        .seed-ctrl {
            display: flex; align-items: center; background: rgba(255,255,255,0.1);
            padding: 4px; border-radius: 4px;
        }
        .seed-ctrl input {
            width: 50px; border: none; border-radius: 2px; 
            text-align: center; padding: 4px; font-weight: bold; font-size: 1rem;
        }
        .seed-ctrl button {
            margin-left: 5px; padding: 5px 10px; cursor: pointer;
            background: #3498db; color: white; border: none; border-radius: 2px;
            font-weight: bold; white-space: nowrap;
        }

        /* --- 3. 中間畫布 (彈性空間) --- */
        #canvas-wrapper {
            flex: 1; /* 自動填滿剩餘空間 */
            min-height: 0; /* 允許縮小 */
            position: relative; background: #fff; width: 100%; 
            overflow: hidden;
            touch-action: none; /* 禁止瀏覽器預設觸控行為 */
        }
        canvas { display: block; width: 100%; height: 100%; }

        /* --- 浮動數據面板 --- */
        #data-panel {
            position: absolute;
            top: 10px; left: 10px;
            width: 160px;
            background: rgba(255, 255, 255, 0.96);
            border: 1px solid #7f8c8d;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            display: flex; flex-direction: column;
            z-index: 90;
            overflow: hidden;
            transition: opacity 0.2s;
            opacity: 0; pointer-events: none; transform: scale(0.9);
            max-height: 60%;
        }
        #data-panel.visible { opacity: 1; pointer-events: auto; transform: scale(1); }

        #panel-header {
            background: #34495e; color: white; padding: 8px 10px;
            cursor: move; font-size: 0.85rem; font-weight: bold;
            display: flex; justify-content: space-between; align-items: center;
            user-select: none;
        }
        .btn-min {
            background: none; border: 1px solid rgba(255,255,255,0.5);
            color: white; border-radius: 4px; width: 24px; height: 24px;
            display: flex; align-items: center; justify-content: center;
            cursor: pointer; font-size: 12px;
        }
        #panel-content { overflow-y: auto; padding: 0; flex: 1; }
        #data-panel.minimized #panel-content { display: none; }
        
        table.data-table { width: 100%; border-collapse: collapse; font-size: 0.8rem; }
        table.data-table th { background: #ecf0f1; text-align: center; padding: 5px; position: sticky; top: 0; }
        table.data-table td { border-bottom: 1px solid #eee; text-align: center; padding: 5px 0; }
        .row-seed { background-color: #fab1a0; }
        .row-active { background-color: #ff7675; color: white; }
        .row-wa { background-color: #ffeaa7; }

        /* --- 4. 底部控制區 --- */
        .footer {
            background: white; border-top: 1px solid #ccc; padding: 8px;
            flex-shrink: 0; /* 禁止被壓縮 */
            display: flex; flex-direction: column; gap: 6px;
            padding-bottom: env(safe-area-inset-bottom); /* 避開 iPhone 底條 */
        }

        .legend {
            display: flex; gap: 10px; font-size: 0.8rem; justify-content: center; color: #666; flex-wrap: wrap;
        }
        .legend span { display: flex; align-items: center; gap: 4px; }
        .dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; }

        .status-bar {
            display: flex; justify-content: space-between;
            background: #f1f2f6; padding: 6px 10px; border-radius: 5px;
            font-size: 0.9rem; color: #555; font-weight: bold;
        }
        .status-bar b { color: #e74c3c; font-size: 1.1rem; }

        .btn-group { display: flex; gap: 6px; height: 44px; }
        .btn {
            flex: 1; border: none; border-radius: 6px;
            font-size: 0.95rem; font-weight: bold; color: white; cursor: pointer;
            padding: 0; display: flex; align-items: center; justify-content: center;
        }
        .btn:active { opacity: 0.8; }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; filter: grayscale(1); }
        
        .btn-reset { background: #95a5a6; flex: 0.5; font-size: 0.9rem;}
        .btn-toggle { background: #34495e; flex: 0.5; font-size: 0.9rem;}
        .btn-ai { background: #8e44ad; flex: 0.6; }
        .btn-start { background: #27ae60; flex: 1.2; font-size: 1.1rem; }

        #toast {
            position: absolute; top: 60px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.85); color: white; padding: 10px 20px;
            border-radius: 20px; font-size: 0.95rem; opacity: 0; pointer-events: none; transition: opacity 0.3s;
            z-index: 100; text-align: center; white-space: nowrap;
        }

        /* ====== 5. 橫向模式 (Landscape) 優化 ====== */
        /* 當高度小於 500px 時 (手機橫放) */
        @media (max-height: 500px) {
            header { height: 40px; padding: 0 8px; }
            .title h1 { font-size: 1rem; }
            .title small { display: none; } /* 隱藏副標題 */
            
            /* 縮小底部間距與按鈕 */
            .footer { padding: 4px 8px; gap: 4px; }
            .legend { display: none; } /* 隱藏圖例 */
            .status-bar { padding: 2px 8px; font-size: 0.8rem; height: 24px; }
            .btn-group { height: 34px; }
            .btn { font-size: 0.85rem; }
            
            /* 調整面板 */
            #data-panel { max-height: 80%; width: 140px; font-size: 0.9em; }
            #panel-header { padding: 4px 8px; }
        }
    </style>
</head>
<body>

<header>
    <div class="title">
        <h1>節點守護者 v7</h1>
        <small>拖曳表格 | 窮舉 AI</small>
    </div>
    <div class="seed-ctrl">
        <input type="number" id="seedInput" value="2026">
        <button onclick="reloadMap()">載入</button>
    </div>
</header>

<div id="canvas-wrapper">
    <canvas id="gameCanvas"></canvas>
    
    <div id="data-panel">
        <div id="panel-header">
            <span>數據驗算</span>
            <button class="btn-min" onclick="toggleMinimize(event)">_</button>
        </div>
        <div id="panel-content">
            <table class="data-table">
                <thead><tr><th>ID</th><th>H</th><th>接收</th></tr></thead>
                <tbody id="data-body"></tbody>
            </table>
        </div>
    </div>

    <div id="toast">請選擇 3 個節點</div>
</div>

<div class="footer">
    <div class="legend">
        <span><i class="dot" style="background:#ecf0f1; border:1px solid #bdc3c7"></i>未啟動</span>
        <span><i class="dot" style="background:#e74c3c"></i>種子</span>
        <span><i class="dot" style="background:#ff7675"></i>擴散</span>
    </div>
    <div class="status-bar">
        <span>種子: <b id="ui-seeds">0</b>/3</span>
        <span>已啟動: <b id="ui-active">0</b>/16</span>
    </div>
    <div class="btn-group">
        <button class="btn btn-reset" onclick="resetGame()">重置</button>
        <button class="btn btn-toggle" onclick="toggleTable()">表格</button>
        <button class="btn btn-ai" onclick="runAI()">AI</button>
        <button class="btn btn-start" id="btn-start" onclick="startSim()" disabled>開始</button>
    </div>
</div>

<script>
// --- 參數 ---
const NODE_COUNT = 16; 
const NODE_RADIUS = 28; 
const MAX_SEEDS = 3;

// --- 變數 ---
let canvas, ctx;
let width, height;
let nodes = []; 
let seeds = new Set();
let isSimulating = false;
let mySeed = 2026;

// ★ 關鍵修正變數：處理點擊 vs 拖曳
let dragNode = null;
let dragStartPos = {x:0, y:0};
let isDraggingNode = false; 
let touchStartTime = 0; // 記錄按下時間

// --- 隨機數 ---
function seededRandom() {
    mySeed = (mySeed * 9301 + 49297) % 233280;
    return mySeed / 233280;
}

window.onload = function() {
    canvas = document.getElementById('gameCanvas');
    ctx = canvas.getContext('2d');
    
    // RWD 設定
    const wrapper = document.getElementById('canvas-wrapper');
    const resizeObserver = new ResizeObserver(() => resizeCanvas());
    resizeObserver.observe(wrapper);
    
    // 事件監聽 (Mouse + Touch)
    canvas.addEventListener('mousedown', onPointerDown);
    canvas.addEventListener('touchstart', onPointerDown, {passive: false});
    
    canvas.addEventListener('mousemove', onPointerMove);
    canvas.addEventListener('touchmove', onPointerMove, {passive: false});
    
    window.addEventListener('mouseup', onPointerUp);
    window.addEventListener('touchend', onPointerUp, {passive: false});

    initDraggablePanel();

    setTimeout(() => {
        resizeCanvas();
        reloadMap();
        requestAnimationFrame(loop);
    }, 100);
};

function resizeCanvas() {
    const wrapper = document.getElementById('canvas-wrapper');
    const rect = wrapper.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    
    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;
    canvas.style.width = '100%';
    canvas.style.height = '100%';
    
    ctx.scale(dpr, dpr);
    width = rect.width;
    height = rect.height;
}

// --- 取得座標 (統一 Touch 與 Mouse) ---
function getPointerPos(e) {
    let rect = canvas.getBoundingClientRect();
    let clientX = e.clientX;
    let clientY = e.clientY;
    
    if(e.touches && e.touches.length > 0) {
        clientX = e.touches[0].clientX;
        clientY = e.touches[0].clientY;
    } else if (e.changedTouches && e.changedTouches.length > 0) {
        clientX = e.changedTouches[0].clientX;
        clientY = e.changedTouches[0].clientY;
    }
    return { x: clientX - rect.left, y: clientY - rect.top };
}

// --- ★ 核心修正：觸控互動邏輯 ---
function onPointerDown(e) {
    if(isSimulating) return;
    if(e.target !== canvas) return;
    // 防止觸控時產生反白或捲動
    if(e.type === 'touchstart') e.preventDefault();

    let pos = getPointerPos(e);
    
    for(let n of nodes) {
        // 1.8倍半徑，讓手指好點
        if(Math.hypot(pos.x - n.x, pos.y - n.y) < NODE_RADIUS * 1.8) {
            dragNode = n;
            dragStartPos = {x: pos.x, y: pos.y};
            isDraggingNode = false;
            touchStartTime = Date.now(); // 記錄按下時間
            return;
        }
    }
}

function onPointerMove(e) {
    if(!dragNode) return;
    if(e.type === 'touchmove') e.preventDefault(); 
    
    let pos = getPointerPos(e);
    if(!isDraggingNode) {
        let dist = Math.hypot(pos.x - dragStartPos.x, pos.y - dragStartPos.y);
        // ★ 防手震：移動超過 10px 才算拖曳
        if(dist > 10) isDraggingNode = true;
    }
    if(isDraggingNode) {
        let p = NODE_RADIUS;
        dragNode.x = Math.max(p, Math.min(width - p, pos.x));
        dragNode.y = Math.max(p, Math.min(height - p, pos.y));
    }
}

function onPointerUp(e) {
    if(e.type === 'touchend' && e.target === canvas) e.preventDefault();

    if(dragNode) {
        let timeDiff = Date.now() - touchStartTime;
        // ★ 判定：如果沒有拖曳，或者動作超快(<200ms)，都視為點擊
        if(!isDraggingNode || timeDiff < 200) {
            toggleSeed(dragNode);
        }
        dragNode = null; 
        isDraggingNode = false;
    }
}

// --- 面板控制 ---
function toggleTable() {
    const panel = document.getElementById('data-panel');
    panel.classList.toggle('visible');
    // 若在小螢幕跑到外面，重置位置
    if(window.innerWidth < 500 && panel.offsetLeft > width - 50) {
        panel.style.left = '10px'; panel.style.top = '10px';
    }
    updateTable();
}

function toggleMinimize(e) {
    e.stopPropagation(); 
    const panel = document.getElementById('data-panel');
    const btn = e.target;
    if(panel.classList.contains('minimized')) {
        panel.classList.remove('minimized'); btn.innerText = '_';
    } else {
        panel.classList.add('minimized'); btn.innerText = '□';
    }
}

function initDraggablePanel() {
    const panel = document.getElementById('data-panel');
    const header = document.getElementById('panel-header');
    let isPanelDragging = false;
    let startX, startY, initialLeft, initialTop;

    const startDrag = (e) => {
        if(e.target.classList.contains('btn-min')) return;
        isPanelDragging = true;
        let clientX = e.clientX || (e.touches ? e.touches[0].clientX : 0);
        let clientY = e.clientY || (e.touches ? e.touches[0].clientY : 0);
        startX = clientX; startY = clientY;
        initialLeft = panel.offsetLeft; initialTop = panel.offsetTop;
        document.addEventListener('mousemove', onDrag);
        document.addEventListener('mouseup', stopDrag);
        document.addEventListener('touchmove', onDrag, {passive: false});
        document.addEventListener('touchend', stopDrag);
    };

    const onDrag = (e) => {
        if(!isPanelDragging) return;
        if(e.type === 'touchmove') e.preventDefault();
        let clientX = e.clientX || (e.touches ? e.touches[0].clientX : 0);
        let clientY = e.clientY || (e.touches ? e.touches[0].clientY : 0);
        let dx = clientX - startX; let dy = clientY - startY;
        let newLeft = initialLeft + dx; let newTop = initialTop + dy;
        let maxLeft = width - panel.offsetWidth; let maxTop = height - panel.offsetHeight;
        panel.style.left = Math.max(0, Math.min(maxLeft, newLeft)) + 'px';
        panel.style.top = Math.max(0, Math.min(maxTop, newTop)) + 'px';
    };

    const stopDrag = () => {
        isPanelDragging = false;
        document.removeEventListener('mousemove', onDrag);
        document.removeEventListener('mouseup', stopDrag);
        document.removeEventListener('touchmove', onDrag);
        document.removeEventListener('touchend', stopDrag);
    };

    header.addEventListener('mousedown', startDrag);
    header.addEventListener('touchstart', startDrag, {passive: false});
}

// --- 遊戲邏輯 ---
function reloadMap() {
    let inputVal = document.getElementById('seedInput').value;
    mySeed = parseInt(inputVal) || 2026;
    resetGameData();
    nodes = [];
    
    let pad = NODE_RADIUS * 1.5;
    let safeW = width - 2 * pad;
    let safeH = height - 2 * pad;
    let attempts = 0;

    while(nodes.length < NODE_COUNT && attempts < 2000) {
        attempts++;
        let x = pad + seededRandom() * safeW;
        let y = pad + seededRandom() * safeH;
        let overlap = false;
        for(let n of nodes) {
            if(Math.hypot(n.x - x, n.y - y) < NODE_RADIUS * 2.5) { overlap = true; break; }
        }
        if(!overlap) {
            nodes.push({
                id: nodes.length + 1, x: x, y: y,
                power: Math.floor(seededRandom() * 9) + 1, 
                threshold: Math.floor(seededRandom() * 4) + 2, 
                currentInput: 0, state: 'normal', neighbors: []
            });
        }
    }

    let connected = [0], unconnected = []; 
    for(let i=1; i<NODE_COUNT; i++) unconnected.push(i);
    let rawPairs = [];

    while(unconnected.length > 0) {
        let u = connected[Math.floor(seededRandom() * connected.length)];
        let bestV = -1, minDist = Infinity, bestIdx = -1;
        for(let k=0; k<5; k++) {
             let idx = Math.floor(seededRandom() * unconnected.length);
             let v = unconnected[idx];
             let d = Math.hypot(nodes[u].x - nodes[v].x, nodes[u].y - nodes[v].y);
             if(d < minDist) { minDist = d; bestV = v; bestIdx = idx; }
        }
        if(bestV === -1) { bestV = unconnected[0]; bestIdx = 0; }
        rawPairs.push({u: u, v: bestV});
        connected.push(bestV); unconnected.splice(bestIdx, 1);
    }
    for(let i=0; i<NODE_COUNT; i++) {
        let u = i, v = Math.floor(seededRandom() * NODE_COUNT);
        if(u !== v && !rawPairs.some(p => (p.u===u && p.v===v) || (p.u===v && p.v===u))) {
             if(Math.hypot(nodes[u].x - nodes[v].x, nodes[u].y - nodes[v].y) < width * 0.45) {
                 rawPairs.push({u: u, v: v});
             }
        }
    }
    let adj = Array.from({length: NODE_COUNT}, () => []);
    rawPairs.forEach(p => { adj[p.u].push(p.v); adj[p.v].push(p.u); });

    for(let i=0; i<NODE_COUNT; i++) {
        let degree = adj[i].length;
        if(degree === 0) continue;
        let wList = [], sum = 0;
        for(let k=0; k<degree; k++) { let r = Math.floor(seededRandom() * 10) + 1; wList.push(r); sum += r; }
        for(let k=0; k<degree; k++) {
            nodes[i].neighbors.push({ target: nodes[adj[i][k]], weight: wList[k] / sum, active: false });
        }
    }
    updateTable();
    showToast(`地圖 ${inputVal} 已載入`);
}

function resetGameData() {
    isSimulating = false;
    seeds.clear();
    nodes.forEach(n => { n.state = 'normal'; n.currentInput = 0; n.neighbors.forEach(e => e.active = false); });
    updateUI(); updateTable();
}

function updateTable() {
    const tbody = document.getElementById('data-body');
    if(!tbody || !document.getElementById('data-panel').classList.contains('visible')) return;
    let html = '';
    [...nodes].sort((a,b) => a.id - b.id).forEach(n => {
        let cls = '';
        let txt = n.currentInput.toFixed(1);
        if(n.state === 'seed') { cls = 'row-seed'; txt = '(種子)'; }
        else if(n.state === 'active') cls = 'row-active';
        else if(n.currentInput > 0) cls = 'row-wa';
        html += `<tr class="${cls}"><td><b>${n.id}</b></td><td>${n.threshold}</td><td>${txt}</td></tr>`;
    });
    tbody.innerHTML = html;
}

function loop() {
    ctx.clearRect(0,0, canvas.width, canvas.height);
    // 繪製背景線
    ctx.fillStyle = '#fff'; ctx.fillRect(0,0, width, height);
    
    nodes.forEach(s => s.neighbors.forEach(e => drawCurve(s, e.target, e.active, e.weight, false)));
    nodes.forEach(n => {
        ctx.beginPath(); ctx.arc(n.x, n.y, NODE_RADIUS, 0, Math.PI*2);
        ctx.shadowColor = 'rgba(0,0,0,0.1)'; ctx.shadowBlur = 4;
        
        if(n.state === 'seed') { ctx.fillStyle = '#e74c3c'; ctx.strokeStyle = '#c0392b'; }
        else if(n.state === 'active') { ctx.fillStyle = '#ff7675'; ctx.strokeStyle = '#d63031'; }
        else if(n.currentInput > 0) { ctx.fillStyle = '#ffeaa7'; ctx.strokeStyle = '#fdcb6e'; }
        else { ctx.fillStyle = '#ecf0f1'; ctx.strokeStyle = '#bdc3c7'; }
        
        ctx.fill(); ctx.shadowBlur = 0; ctx.lineWidth = 2; ctx.stroke();
        ctx.fillStyle = '#2d3436'; ctx.font = 'bold 16px Arial'; 
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText(n.id, n.x, n.y);
        ctx.fillStyle = '#555'; ctx.font = 'bold 11px Arial';
        ctx.fillText(`${n.power} | ${n.threshold}`, n.x, n.y + NODE_RADIUS + 12);
        if(n.state !== 'seed' && n.currentInput > 0) {
            ctx.fillStyle = '#0984e3'; ctx.font = 'bold 13px Arial';
            ctx.fillText(`R:${n.currentInput.toFixed(1)}`, n.x, n.y - NODE_RADIUS - 12);
        }
    });
    nodes.forEach(s => s.neighbors.forEach(e => drawCurve(s, e.target, e.active, e.weight, true)));
    requestAnimationFrame(loop);
}

function drawCurve(s, t, active, w, drawLabel) {
    let dx = t.x - s.x, dy = t.y - s.y, dist = Math.sqrt(dx*dx + dy*dy);
    if(dist < 1) return;
    let midX = (s.x + t.x) / 2, midY = (s.y + t.y) / 2;
    let offset = 30; 
    let cx = midX - dy/dist * offset; let cy = midY + dx/dist * offset;

    if(!drawLabel) {
        ctx.beginPath(); ctx.moveTo(s.x, s.y); ctx.quadraticCurveTo(cx, cy, t.x, t.y);
        if(active) { ctx.strokeStyle = '#f1c40f'; ctx.lineWidth = 4; } 
        else { ctx.strokeStyle = '#ccc'; ctx.lineWidth = 1.5; }
        ctx.stroke();
        let it = 0.15; // 箭頭位置
        let ax = it*it*s.x + 2*it*(1-it)*cx + (1-it)*(1-it)*t.x; // 這裡反向計算有點複雜，直接簡化
        // 箭頭
        let t_ = 0.85, it_ = 1-t_;
        let ax_ = it_*it_*s.x + 2*it_*t_*cx + t_*t_*t.x;
        let ay_ = it_*it_*s.y + 2*it_*t_*cy + t_*t_*t.y;
        let tx = 2*it_*(cx-s.x) + 2*t_*(t.x-cx);
        let ty = 2*it_*(cy-s.y) + 2*t_*(t.y-cy);
        ctx.save(); ctx.translate(ax_, ay_); ctx.rotate(Math.atan2(ty, tx));
        ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(-7,-3.5); ctx.lineTo(-7,3.5);
        ctx.fillStyle = ctx.strokeStyle; ctx.fill(); ctx.restore();
    } else {
        let t_ = 0.4, it_ = 1-t_;
        let lx = it_*it_*s.x + 2*it_*t_*cx + t_*t_*t.x;
        let ly = it_*it_*s.y + 2*it_*t_*cy + t_*t_*t.y;
        let txt = Math.round(w * 100) + "%";
        ctx.fillStyle = 'rgba(255,255,255,0.85)';
        let tw = ctx.measureText(txt).width + 4;
        ctx.fillRect(lx - tw/2, ly - 8, tw, 16);
        ctx.fillStyle = '#555'; ctx.font = '10px Arial';
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText(txt, lx, ly);
    }
}

function toggleSeed(n) {
    if(seeds.has(n)) {
        seeds.delete(n); n.state = 'normal'; n.currentInput = 0;
    } else {
        if(seeds.size >= MAX_SEEDS) { showToast("已達 3 個上限"); return; }
        seeds.add(n); n.state = 'seed'; n.currentInput = n.threshold + 99; 
    }
    updateUI(); updateTable();
}

function updateUI() {
    document.getElementById('ui-seeds').innerText = seeds.size;
    let active = nodes.filter(n => n.state === 'seed' || n.state === 'active').length;
    document.getElementById('ui-active').innerText = active;
    document.getElementById('btn-start').disabled = (seeds.size === 0);
}

function showToast(msg) {
    let t = document.getElementById('toast');
    t.innerText = msg; t.style.opacity = 1;
    setTimeout(()=>t.style.opacity=0, 2000);
}

async function startSim() {
    isSimulating = true;
    document.querySelectorAll('.btn').forEach(b => b.disabled = true);
    showToast("能量傳遞中...");
    let queue = [...seeds];
    let visitedEdges = new Set();
    while(queue.length > 0) {
        await new Promise(r => setTimeout(r, 800));
        let nextQueue = [];
        for(let source of queue) {
            for(let edge of source.neighbors) {
                let key = `${source.id}-${edge.target.id}`;
                if(visitedEdges.has(key)) continue;
                let target = edge.target;
                if(target.state === 'seed') { visitedEdges.add(key); continue; }
                visitedEdges.add(key);
                edge.active = true;
                target.currentInput += source.power * edge.weight;
            }
        }
        nodes.forEach(n => {
            if(n.state === 'normal' && n.currentInput > n.threshold) {
                n.state = 'active'; nextQueue.push(n);
            }
        });
        queue = nextQueue;
        updateUI(); updateTable(); 
    }
    showToast("模擬結束");
    document.querySelector('.btn-reset').disabled = false;
    document.querySelector('.btn-toggle').disabled = false;
    document.querySelector('.btn-ai').disabled = false;
}

function resetGame() {
    resetGameData();
    document.querySelectorAll('.btn').forEach(b => b.disabled = false);
    document.getElementById('btn-start').disabled = true;
}

// AI 運算 (暴力窮舉)
function runAI() {
    if(isSimulating) return;
    resetGame();
    showToast("AI 窮舉中... (請稍候)");
    
    // 延遲執行以免卡住 UI
    setTimeout(() => {
        const staticData = nodes.map(n => ({
            id: n.id, power: n.power, threshold: n.threshold,
            edges: n.neighbors.map(e => ({ targetId: e.target.id, weight: e.weight }))
        }));

        let bestCombination = [];
        let maxScore = -1;

        for(let i = 0; i < NODE_COUNT; i++) {
            for(let j = i + 1; j < NODE_COUNT; j++) {
                for(let k = j + 1; k < NODE_COUNT; k++) {
                    let testSet = [i, j, k]; 
                    let score = fastSimulate(staticData, testSet);
                    if(score > maxScore) {
                        maxScore = score;
                        bestCombination = testSet;
                    }
                }
            }
        }
        bestCombination.forEach(idx => toggleSeed(nodes[idx]));
        showToast(`AI 最佳解: ${maxScore} 個`);
    }, 100);
}

function fastSimulate(graph, seedIndices) {
    let states = new Array(graph.length).fill(0); 
    let inputs = new Array(graph.length).fill(0);
    let visitedEdges = new Set();
    let queue = [];
    seedIndices.forEach(idx => { states[idx] = 1; queue.push(idx); });
    let activeCount = seedIndices.length;

    while(queue.length > 0) {
        let nextQueue = [];
        for(let uIdx of queue) {
            let u = graph[uIdx];
            for(let edge of u.edges) {
                let targetIdx = edge.targetId - 1; 
                let key = `${uIdx}-${targetIdx}`;
                if(visitedEdges.has(key)) continue;
                visitedEdges.add(key);
                if(states[targetIdx] === 1) continue; 
                inputs[targetIdx] += u.power * edge.weight;
            }
        }
        for(let i=0; i<graph.length; i++) {
            if(states[i] === 0 && inputs[i] > graph[i].threshold) {
                states[i] = 1; nextQueue.push(i); activeCount++;
            }
        }
        queue = nextQueue;
    }
    return activeCount;
}
</script>
</body>
</html>
